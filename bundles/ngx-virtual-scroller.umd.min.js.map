{"version":3,"sources":["../../node_modules/tslib/tslib.es6.js","ng://ngx-virtual-scroller/virtual-scroller.ts"],"names":["__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","create","VIRTUAL_SCROLLER_DEFAULT_OPTIONS_FACTORY","checkResizeInterval","modifyOverflowStyleOfParentScroll","resizeBypassRefreshThreshold","scrollAnimationTime","scrollDebounceTime","scrollThrottlingTime","stripedTable","VirtualScrollerComponent","element","renderer","zone","changeDetectorRef","platformId","options","this","window","executeRefreshOutsideAngularZone","_enableUnequalChildrenSizes","RTL","useMarginInsteadOfTranslate","ssrViewportWidth","ssrViewportHeight","_items","vsUpdate","EventEmitter","vsChange","vsStart","vsEnd","calculatedScrollbarWidth","calculatedScrollbarHeight","padding","previousViewPort","cachedPageSize","previousScrollNumberElements","compareItems","item1","item2","isAngularUniversalSSR","isPlatformServer","scrollbarHeight","scrollbarWidth","horizontal","resetWrapGroupDimensions","prototype","pageInfo","startIndex","endIndex","scrollStartPosition","scrollEndPosition","maxScrollPosition","startIndexWithBuffer","endIndexWithBuffer","value","minMeasuredChildWidth","undefined","minMeasuredChildHeight","_bufferAmount","enableUnequalChildrenSizes","_scrollThrottlingTime","updateOnScrollFunction","_scrollDebounceTime","_checkResizeInterval","addScrollEventHandlers","refresh_internal","_horizontal","updateDirection","_parentScroll","revertParentOverscroll","scrollElement","getScrollElement","nativeElement","oldParentScrollOverflow","x","style","y","_this_1","onScroll","debounce","throttleTrailing","ngOnInit","ngOnDestroy","removeScrollEventHandlers","ngOnChanges","changes","indexLengthChanged","cachedItemsLength","items","firstRun","previousValue","ngDoCheck","viewPortItems","itemsArrayChanged","refresh","invalidateAllCachedMeasurements","wrapGroupDimensions","maxChildSizePerWrapGroup","numberOfKnownWrapGroupChildSizes","sumOfKnownWrapGroupChildWidths","sumOfKnownWrapGroupChildHeights","invalidateCachedMeasurementForItem","item","index","indexOf","invalidateCachedMeasurementAtIndex","cachedMeasurement","childWidth","childHeight","scrollInto","alignToBeginning","additionalOffset","animationMilliseconds","animationCompletedCallback","scrollToIndex","maxRetries","retryIfNeeded","dimensions","calculateDimensions","desiredStartIndex","Math","min","max","itemCount","scrollToIndex_internal","scroll","calculatePadding","wrapGroupsPerPage","_childScrollDim","scrollToPosition","scrollPosition","getElementsOffset","animationRequest","currentTween","stop","setProperty","_scrollType","tweenConfigObj","newTween","tween.Tween","to","easing","tween.Easing","Quadratic","Out","onUpdate","data","isNaN","onStop","cancelAnimationFrame","start","animate","time","isPlaying","update","runOutsideAngular","requestAnimationFrame","getElementSize","result","getBoundingClientRect","styles","getComputedStyle","marginTop","parseInt","marginBottom","marginLeft","marginRight","top","bottom","left","right","width","height","checkScrollElementResized","sizeChanged","boundingRect","previousScrollBoundingRect","widthChange","abs","heightChange","_invisiblePaddingProperty","_marginDir","_offsetType","_pageOffsetType","_translateDir","func","wait","throttled","cancel","apply","timeout","_arguments","_this","setTimeout","clearTimeout","itemsArrayModified","refreshCompletedCallback","maxRunTimes","oldViewPort_1","oldViewPortItems_1","oldRefreshCompletedCallback_1","scrollLengthDelta","scrollLength","offset","oldStartItem_1","oldStartItemIndex","findIndex","itemOrderChanged","l","viewport","calculateViewport","startChanged","endChanged","scrollLengthChanged","paddingChanged","scrollPositionChanged","setStyle","invisiblePaddingElementRef","contentElementRef","headerElementRef","containerOffset","clientHeight","changeEventArg","handleChanged","slice","emit","markForCheck","run","parentScroll","Window","document","scrollingElement","documentElement","body","disposeScrollHandler","listen","disposeResizeHandler","checkScrollElementResizedTimer","setInterval","clearInterval","containerElementRef","elementClientRect","scrollClientRect","countItemsPerWrapGroup","round","ssrChildHeight","ssrChildWidth","propertyName","children","childrenLength","firstOffset","getScrollStartPosition","windowScrollValue","oldWrapGroupDimensions","itemsPerWrapGroup","wrapGroupIndex","oldWrapGroupDimension","itemsChanged","arrayStartIndex","offsetHeight","offsetWidth","clientWidth","defaultChildWidth","defaultChildHeight","viewportWidth","viewportHeight","content","itemsPerRow","ceil","itemsPerCol","scrollOffset","maxWidthForWrapGroup","maxHeightForWrapGroup","sumOfVisibleMaxWidths","sumOfVisibleMaxHeights","child","clientRect","oldValue","maxVisibleWidthForWrapGroup","scrollOffsetToRemove","maxVisibleHeightForWrapGroup","averageChildWidth","averageChildHeight","itemsPerPage","pageCountFractional","numberOfWrapGroups","defaultScrollLengthPerWrapGroup","numUnknownChildSizes","childSize","viewportLength","pageCount_fractional","arrayStartIndexWithBuffer","startingWrapGroupIndex","floor","calculatePageInfo","scrollPercentage","totalScrolledLength","startingArrayIndexFractional","maxStart","bufferBoundary","arrayEndIndex","endIndexWithinWrapGroup","bufferSize","bufferAmount","newPadding","newScrollLength","ElementRef","Renderer2","NgZone","ChangeDetectorRef","type","Inject","args","PLATFORM_ID","Optional","Input","Output","ViewChild","read","static","ContentChild","Component","selector","exportAs","template","host","[class.horizontal]","[class.vertical]","[class.selfScroll]","[class.rtl]","VirtualScrollerModule","NgModule","exports","declarations","imports","CommonModule","providers","provide","useFactory"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","import {\n    ChangeDetectorRef,\n    Component,\n    ContentChild, DoCheck,\n    ElementRef,\n    EventEmitter,\n    Inject,\n    Input,\n    NgModule,\n    NgZone,\n    OnChanges,\n    OnDestroy,\n    OnInit,\n    Optional,\n    Output,\n    Renderer2,\n    ViewChild,\n} from '@angular/core';\n\nimport {PLATFORM_ID} from '@angular/core';\nimport {isPlatformServer} from '@angular/common';\n\nimport {CommonModule} from '@angular/common';\n\nimport * as tween from '@tweenjs/tween.js'\n\nexport interface VirtualScrollerDefaultOptions {\n    checkResizeInterval: number\n    modifyOverflowStyleOfParentScroll: boolean,\n    resizeBypassRefreshThreshold: number,\n    scrollAnimationTime: number;\n    scrollDebounceTime: number;\n    scrollThrottlingTime: number;\n    scrollbarHeight?: number;\n    scrollbarWidth?: number;\n    stripedTable: boolean\n}\n\nexport function VIRTUAL_SCROLLER_DEFAULT_OPTIONS_FACTORY(): VirtualScrollerDefaultOptions {\n    return {\n        checkResizeInterval: 1000,\n        modifyOverflowStyleOfParentScroll: true,\n        resizeBypassRefreshThreshold: 5,\n        scrollAnimationTime: 750,\n        scrollDebounceTime: 0,\n        scrollThrottlingTime: 0,\n        stripedTable: false\n    };\n}\n\nexport interface WrapGroupDimensions {\n    maxChildSizePerWrapGroup: WrapGroupDimension[];\n    numberOfKnownWrapGroupChildSizes: number;\n    sumOfKnownWrapGroupChildHeights: number;\n    sumOfKnownWrapGroupChildWidths: number;\n}\n\nexport interface WrapGroupDimension {\n    childHeight: number;\n    childWidth: number;\n    items: any[];\n}\n\nexport interface IDimensions {\n    childHeight: number;\n    childWidth: number;\n    itemCount: number;\n    itemsPerPage: number;\n    itemsPerWrapGroup: number;\n    maxScrollPosition: number;\n    pageCount_fractional: number;\n    scrollLength: number;\n    viewportLength: number;\n    wrapGroupsPerPage: number;\n}\n\nexport interface IPageInfo {\n    endIndex: number;\n    endIndexWithBuffer: number;\n    maxScrollPosition: number;\n    scrollEndPosition: number;\n    scrollStartPosition: number;\n    startIndex: number;\n    startIndexWithBuffer: number;\n}\n\nexport interface IViewport extends IPageInfo {\n    padding: number;\n    scrollLength: number;\n}\n\n@Component({\n    selector: 'virtual-scroller,[virtualScroller]',\n    exportAs: 'virtualScroller',\n    template: `\n        <div class=\"total-padding\" #invisiblePadding></div>\n        <div class=\"scrollable-content\" #content>\n            <ng-content></ng-content>\n        </div>\n    `,\n    host: {\n        '[class.horizontal]': 'horizontal',\n        '[class.vertical]': '!horizontal',\n        '[class.selfScroll]': '!parentScroll',\n        '[class.rtl]': 'RTL'\n    },\n    styles: [`\n        :host {\n            position: relative;\n            display: block;\n            -webkit-overflow-scrolling: touch;\n        }\n\n        :host.horizontal.selfScroll {\n            overflow-y: visible;\n            overflow-x: auto;\n        }\n\n        :host.horizontal.selfScroll.rtl {\n            transform: scaleX(-1);\n        }\n\n        :host.vertical.selfScroll {\n            overflow-y: auto;\n            overflow-x: visible;\n        }\n\n        .scrollable-content {\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            max-width: 100vw;\n            max-height: 100vh;\n            position: absolute;\n        }\n\n        .scrollable-content ::ng-deep > * {\n            box-sizing: border-box;\n        }\n\n        :host.horizontal {\n            white-space: nowrap;\n        }\n\n        :host.horizontal .scrollable-content {\n            display: flex;\n        }\n\n        :host.horizontal .scrollable-content ::ng-deep > * {\n            flex-shrink: 0;\n            flex-grow: 0;\n            white-space: initial;\n        }\n\n        :host.horizontal.rtl .scrollable-content ::ng-deep > * {\n            transform: scaleX(-1);\n        }\n\n        .total-padding {\n            position: absolute;\n            top: 0;\n            left: 0;\n            height: 1px;\n            width: 1px;\n            transform-origin: 0 0;\n            opacity: 0;\n        }\n\n        :host.horizontal .total-padding {\n            height: 100%;\n        }\n    `]\n})\nexport class VirtualScrollerComponent implements OnInit, OnChanges, OnDestroy, DoCheck {\n\n    public get viewPortInfo(): IPageInfo {\n        const pageInfo: IViewport = this.previousViewPort || ({} as any);\n        return {\n            startIndex: pageInfo.startIndex || 0,\n            endIndex: pageInfo.endIndex || 0,\n            scrollStartPosition: pageInfo.scrollStartPosition || 0,\n            scrollEndPosition: pageInfo.scrollEndPosition || 0,\n            maxScrollPosition: pageInfo.maxScrollPosition || 0,\n            startIndexWithBuffer: pageInfo.startIndexWithBuffer || 0,\n            endIndexWithBuffer: pageInfo.endIndexWithBuffer || 0\n        };\n    }\n\n    @Input()\n    public get enableUnequalChildrenSizes(): boolean {\n        return this._enableUnequalChildrenSizes;\n    }\n\n    public set enableUnequalChildrenSizes(value: boolean) {\n        if (this._enableUnequalChildrenSizes === value) {\n            return;\n        }\n\n        this._enableUnequalChildrenSizes = value;\n        this.minMeasuredChildWidth = undefined;\n        this.minMeasuredChildHeight = undefined;\n    }\n\n    @Input()\n    public get bufferAmount(): number {\n        if (typeof (this._bufferAmount) === 'number' && this._bufferAmount >= 0) {\n            return this._bufferAmount;\n        } else {\n            return this.enableUnequalChildrenSizes ? 5 : 0;\n        }\n    }\n\n    public set bufferAmount(value: number) {\n        this._bufferAmount = value;\n    }\n\n    @Input()\n    public get scrollThrottlingTime(): number {\n        return this._scrollThrottlingTime;\n    }\n\n    public set scrollThrottlingTime(value: number) {\n        this._scrollThrottlingTime = value;\n        this.updateOnScrollFunction();\n    }\n\n    @Input()\n    public get scrollDebounceTime(): number {\n        return this._scrollDebounceTime;\n    }\n\n    public set scrollDebounceTime(value: number) {\n        this._scrollDebounceTime = value;\n        this.updateOnScrollFunction();\n    }\n\n    @Input()\n    public get checkResizeInterval(): number {\n        return this._checkResizeInterval;\n    }\n\n    public set checkResizeInterval(value: number) {\n        if (this._checkResizeInterval === value) {\n            return;\n        }\n\n        this._checkResizeInterval = value;\n        this.addScrollEventHandlers();\n    }\n\n    @Input()\n    public get items(): any[] {\n        return this._items;\n    }\n\n    public set items(value: any[]) {\n        if (value === this._items) {\n            return;\n        }\n\n        this._items = value || [];\n        this.refresh_internal(true);\n    }\n\n    @Input()\n    public get horizontal(): boolean {\n        return this._horizontal;\n    }\n\n    public set horizontal(value: boolean) {\n        this._horizontal = value;\n        this.updateDirection();\n    }\n\n    @Input()\n    public get parentScroll(): Element | Window {\n        return this._parentScroll;\n    }\n\n    public set parentScroll(value: Element | Window) {\n        if (this._parentScroll === value) {\n            return;\n        }\n\n        this.revertParentOverscroll();\n        this._parentScroll = value;\n        this.addScrollEventHandlers();\n\n        const scrollElement = this.getScrollElement();\n        if (this.modifyOverflowStyleOfParentScroll && scrollElement !== this.element.nativeElement) {\n            this.oldParentScrollOverflow = {x: scrollElement.style['overflow-x'], y: scrollElement.style['overflow-y']};\n            scrollElement.style['overflow-y'] = this.horizontal ? 'visible' : 'auto';\n            scrollElement.style['overflow-x'] = this.horizontal ? 'auto' : 'visible';\n        }\n    }\n\n    constructor(\n        protected readonly element: ElementRef,\n        protected readonly renderer: Renderer2,\n        protected readonly zone: NgZone,\n        protected changeDetectorRef: ChangeDetectorRef,\n        // tslint:disable-next-line:ban-types\n        @Inject(PLATFORM_ID) platformId: Object,\n        @Optional() @Inject('virtual-scroller-default-options')\n            options: VirtualScrollerDefaultOptions\n    ) {\n\n        this.isAngularUniversalSSR = isPlatformServer(platformId);\n\n        this.checkResizeInterval = options.checkResizeInterval;\n        this.modifyOverflowStyleOfParentScroll = options.modifyOverflowStyleOfParentScroll;\n        this.resizeBypassRefreshThreshold = options.resizeBypassRefreshThreshold;\n        this.scrollAnimationTime = options.scrollAnimationTime;\n        this.scrollDebounceTime = options.scrollDebounceTime;\n        this.scrollThrottlingTime = options.scrollThrottlingTime;\n        this.scrollbarHeight = options.scrollbarHeight;\n        this.scrollbarWidth = options.scrollbarWidth;\n        this.stripedTable = options.stripedTable;\n\n        this.horizontal = false;\n        this.resetWrapGroupDimensions();\n    }\n\n    public viewPortItems: any[];\n    public window = window;\n\n    @Input()\n    public executeRefreshOutsideAngularZone = false;\n\n    protected _enableUnequalChildrenSizes = false;\n\n    @Input()\n    public RTL = false;\n\n    @Input()\n    public useMarginInsteadOfTranslate = false;\n\n    @Input()\n    public modifyOverflowStyleOfParentScroll: boolean;\n\n    @Input()\n    public stripedTable: boolean;\n\n    @Input()\n    public scrollbarWidth: number;\n\n    @Input()\n    public scrollbarHeight: number;\n\n    @Input()\n    public childWidth: number;\n\n    @Input()\n    public childHeight: number;\n\n    @Input()\n    public ssrChildWidth: number;\n\n    @Input()\n    public ssrChildHeight: number;\n\n    @Input()\n    public ssrViewportWidth = 1920;\n\n    @Input()\n    public ssrViewportHeight = 1080;\n\n    protected _bufferAmount: number;\n\n    @Input()\n    public scrollAnimationTime: number;\n\n    @Input()\n    public resizeBypassRefreshThreshold: number;\n\n    protected _scrollThrottlingTime: number;\n\n    protected _scrollDebounceTime: number;\n\n    protected onScroll: () => void;\n\n    protected checkScrollElementResizedTimer: number;\n    protected _checkResizeInterval: number;\n\n    protected _items: any[] = [];\n\n    protected _horizontal: boolean;\n\n    protected oldParentScrollOverflow: { x: string, y: string };\n    protected _parentScroll: Element | Window;\n\n    @Output()\n    public vsUpdate: EventEmitter<any[]> = new EventEmitter<any[]>();\n\n    @Output()\n    public vsChange: EventEmitter<IPageInfo> = new EventEmitter<IPageInfo>();\n\n    @Output()\n    public vsStart: EventEmitter<IPageInfo> = new EventEmitter<IPageInfo>();\n\n    @Output()\n    public vsEnd: EventEmitter<IPageInfo> = new EventEmitter<IPageInfo>();\n\n    @ViewChild('content', {read: ElementRef, static: true})\n    protected contentElementRef: ElementRef;\n\n    @ViewChild('invisiblePadding', {read: ElementRef, static: true})\n    protected invisiblePaddingElementRef: ElementRef;\n\n    @ContentChild('header', {read: ElementRef, static: false})\n    protected headerElementRef: ElementRef;\n\n    @ContentChild('container', {read: ElementRef, static: false})\n    protected containerElementRef: ElementRef;\n\n    protected isAngularUniversalSSR: boolean;\n\n    protected previousScrollBoundingRect: ClientRect;\n\n    protected _invisiblePaddingProperty;\n    protected _offsetType;\n    protected _scrollType;\n    protected _pageOffsetType;\n    protected _childScrollDim;\n    protected _translateDir;\n    protected _marginDir;\n\n    protected calculatedScrollbarWidth = 0;\n    protected calculatedScrollbarHeight = 0;\n\n    protected padding = 0;\n    protected previousViewPort: IViewport = {} as any;\n    protected currentTween: tween.Tween;\n    protected cachedItemsLength: number;\n\n    protected disposeScrollHandler: () => void | undefined;\n    protected disposeResizeHandler: () => void | undefined;\n\n    protected minMeasuredChildWidth: number;\n    protected minMeasuredChildHeight: number;\n\n    protected wrapGroupDimensions: WrapGroupDimensions;\n\n    protected cachedPageSize = 0;\n    protected previousScrollNumberElements = 0;\n\n    protected updateOnScrollFunction(): void {\n        if (this.scrollDebounceTime) {\n            this.onScroll = (this.debounce(() => {\n                this.refresh_internal(false);\n            }, this.scrollDebounceTime) as any);\n        } else if (this.scrollThrottlingTime) {\n            this.onScroll = (this.throttleTrailing(() => {\n                this.refresh_internal(false);\n            }, this.scrollThrottlingTime) as any);\n        } else {\n            this.onScroll = () => {\n                this.refresh_internal(false);\n            };\n        }\n    }\n\n    @Input()\n    public compareItems: (item1: any, item2: any) => boolean = (item1: any, item2: any) => item1 === item2;\n\n    protected revertParentOverscroll(): void {\n        const scrollElement = this.getScrollElement();\n        if (scrollElement && this.oldParentScrollOverflow) {\n            scrollElement.style['overflow-y'] = this.oldParentScrollOverflow.y;\n            scrollElement.style['overflow-x'] = this.oldParentScrollOverflow.x;\n        }\n\n        this.oldParentScrollOverflow = undefined;\n    }\n\n    public ngOnInit(): void {\n        this.addScrollEventHandlers();\n    }\n\n    public ngOnDestroy(): void {\n        this.removeScrollEventHandlers();\n        this.revertParentOverscroll();\n    }\n\n    public ngOnChanges(changes: any): void {\n        const indexLengthChanged = this.cachedItemsLength !== this.items.length;\n        this.cachedItemsLength = this.items.length;\n\n        const firstRun: boolean = !changes.items || !changes.items.previousValue || changes.items.previousValue.length === 0;\n        this.refresh_internal(indexLengthChanged || firstRun);\n    }\n\n    public ngDoCheck(): void {\n        if (this.cachedItemsLength !== this.items.length) {\n            this.cachedItemsLength = this.items.length;\n            this.refresh_internal(true);\n            return;\n        }\n\n        if (this.previousViewPort && this.viewPortItems && this.viewPortItems.length > 0) {\n            let itemsArrayChanged = false;\n            for (let i = 0; i < this.viewPortItems.length; ++i) {\n                if (!this.compareItems(this.items[this.previousViewPort.startIndexWithBuffer + i], this.viewPortItems[i])) {\n                    itemsArrayChanged = true;\n                    break;\n                }\n            }\n            if (itemsArrayChanged) {\n                this.refresh_internal(true);\n            }\n        }\n    }\n\n    public refresh(): void {\n        this.refresh_internal(true);\n    }\n\n    public invalidateAllCachedMeasurements(): void {\n        this.wrapGroupDimensions = {\n            maxChildSizePerWrapGroup: [],\n            numberOfKnownWrapGroupChildSizes: 0,\n            sumOfKnownWrapGroupChildWidths: 0,\n            sumOfKnownWrapGroupChildHeights: 0\n        };\n\n        this.minMeasuredChildWidth = undefined;\n        this.minMeasuredChildHeight = undefined;\n\n        this.refresh_internal(false);\n    }\n\n    public invalidateCachedMeasurementForItem(item: any): void {\n        if (this.enableUnequalChildrenSizes) {\n            const index = this.items && this.items.indexOf(item);\n            if (index >= 0) {\n                this.invalidateCachedMeasurementAtIndex(index);\n            }\n        } else {\n            this.minMeasuredChildWidth = undefined;\n            this.minMeasuredChildHeight = undefined;\n        }\n\n        this.refresh_internal(false);\n    }\n\n    public invalidateCachedMeasurementAtIndex(index: number): void {\n        if (this.enableUnequalChildrenSizes) {\n            const cachedMeasurement = this.wrapGroupDimensions.maxChildSizePerWrapGroup[index];\n            if (cachedMeasurement) {\n                this.wrapGroupDimensions.maxChildSizePerWrapGroup[index] = undefined;\n                --this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\n                this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths -= cachedMeasurement.childWidth || 0;\n                this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights -= cachedMeasurement.childHeight || 0;\n            }\n        } else {\n            this.minMeasuredChildWidth = undefined;\n            this.minMeasuredChildHeight = undefined;\n        }\n\n        this.refresh_internal(false);\n    }\n\n    public scrollInto(item: any, alignToBeginning: boolean = true, additionalOffset: number = 0,\n                      animationMilliseconds?: number, animationCompletedCallback?: () => void): void {\n        const index: number = this.items.indexOf(item);\n        if (index === -1) {\n            return;\n        }\n\n        this.scrollToIndex(index, alignToBeginning, additionalOffset, animationMilliseconds, animationCompletedCallback);\n    }\n\n    public scrollToIndex(index: number, alignToBeginning: boolean = true, additionalOffset: number = 0,\n                         animationMilliseconds?: number, animationCompletedCallback?: () => void): void {\n        let maxRetries = 5;\n\n        const retryIfNeeded = () => {\n            --maxRetries;\n            if (maxRetries <= 0) {\n                if (animationCompletedCallback) {\n                    animationCompletedCallback();\n                }\n                return;\n            }\n\n            const dimensions = this.calculateDimensions();\n            const desiredStartIndex = Math.min(Math.max(index, 0), dimensions.itemCount - 1);\n            if (this.previousViewPort.startIndex === desiredStartIndex) {\n                if (animationCompletedCallback) {\n                    animationCompletedCallback();\n                }\n                return;\n            }\n\n            this.scrollToIndex_internal(index, alignToBeginning, additionalOffset, 0, retryIfNeeded);\n        };\n\n        this.scrollToIndex_internal(index, alignToBeginning, additionalOffset, animationMilliseconds, retryIfNeeded);\n    }\n\n    protected scrollToIndex_internal(index: number, alignToBeginning: boolean = true, additionalOffset: number = 0,\n                                     animationMilliseconds?: number, animationCompletedCallback?: () => void): void {\n        animationMilliseconds = animationMilliseconds === undefined ? this.scrollAnimationTime : animationMilliseconds;\n\n        const dimensions = this.calculateDimensions();\n        let scroll = this.calculatePadding(index, dimensions) + additionalOffset;\n        if (!alignToBeginning) {\n            scroll -= dimensions.wrapGroupsPerPage * dimensions[this._childScrollDim];\n        }\n\n        this.scrollToPosition(scroll, animationMilliseconds, animationCompletedCallback);\n    }\n\n    public scrollToPosition(scrollPosition: number, animationMilliseconds?: number, animationCompletedCallback?: () => void): void {\n        scrollPosition += this.getElementsOffset();\n\n        animationMilliseconds = animationMilliseconds === undefined ? this.scrollAnimationTime : animationMilliseconds;\n\n        const scrollElement = this.getScrollElement();\n\n        let animationRequest: number;\n\n        if (this.currentTween) {\n            this.currentTween.stop();\n            this.currentTween = undefined;\n        }\n\n        if (!animationMilliseconds) {\n            this.renderer.setProperty(scrollElement, this._scrollType, scrollPosition);\n            this.refresh_internal(false, animationCompletedCallback);\n            return;\n        }\n\n        const tweenConfigObj = {scrollPosition: scrollElement[this._scrollType]};\n\n        const newTween = new tween.Tween(tweenConfigObj)\n            .to({scrollPosition}, animationMilliseconds)\n            .easing(tween.Easing.Quadratic.Out)\n            .onUpdate((data) => {\n                if (isNaN(data.scrollPosition)) {\n                    return;\n                }\n                this.renderer.setProperty(scrollElement, this._scrollType, data.scrollPosition);\n                this.refresh_internal(false);\n            })\n            .onStop(() => {\n                cancelAnimationFrame(animationRequest);\n            })\n            .start();\n\n        const animate = (time?: number) => {\n            if (!newTween.isPlaying()) {\n                return;\n            }\n\n            newTween.update(time);\n            if (tweenConfigObj.scrollPosition === scrollPosition) {\n                this.refresh_internal(false, animationCompletedCallback);\n                return;\n            }\n\n            this.zone.runOutsideAngular(() => {\n                animationRequest = requestAnimationFrame(animate);\n            });\n        };\n\n        animate();\n        this.currentTween = newTween;\n    }\n\n    protected getElementSize(element: HTMLElement): ClientRect {\n        const result = element.getBoundingClientRect();\n        const styles = getComputedStyle(element);\n        const marginTop = parseInt(styles['margin-top'], 10) || 0;\n        const marginBottom = parseInt(styles['margin-bottom'], 10) || 0;\n        const marginLeft = parseInt(styles['margin-left'], 10) || 0;\n        const marginRight = parseInt(styles['margin-right'], 10) || 0;\n\n        return {\n            top: result.top + marginTop,\n            bottom: result.bottom + marginBottom,\n            left: result.left + marginLeft,\n            right: result.right + marginRight,\n            width: result.width + marginLeft + marginRight,\n            height: result.height + marginTop + marginBottom\n        };\n    }\n\n    protected checkScrollElementResized(): void {\n        const boundingRect = this.getElementSize(this.getScrollElement());\n\n        let sizeChanged: boolean;\n        if (!this.previousScrollBoundingRect) {\n            sizeChanged = true;\n        } else {\n            const widthChange = Math.abs(boundingRect.width - this.previousScrollBoundingRect.width);\n            const heightChange = Math.abs(boundingRect.height - this.previousScrollBoundingRect.height);\n            sizeChanged = widthChange > this.resizeBypassRefreshThreshold || heightChange > this.resizeBypassRefreshThreshold;\n        }\n\n        if (sizeChanged) {\n            this.previousScrollBoundingRect = boundingRect;\n            if (boundingRect.width > 0 && boundingRect.height > 0) {\n                this.refresh_internal(false);\n            }\n        }\n    }\n\n    protected updateDirection(): void {\n        if (this.horizontal) {\n            this._childScrollDim = 'childWidth';\n            this._invisiblePaddingProperty = 'scaleX';\n            this._marginDir = 'margin-left';\n            this._offsetType = 'offsetLeft';\n            this._pageOffsetType = 'pageXOffset';\n            this._scrollType = 'scrollLeft';\n            this._translateDir = 'translateX';\n        } else {\n            this._childScrollDim = 'childHeight';\n            this._invisiblePaddingProperty = 'scaleY';\n            this._marginDir = 'margin-top';\n            this._offsetType = 'offsetTop';\n            this._pageOffsetType = 'pageYOffset';\n            this._scrollType = 'scrollTop';\n            this._translateDir = 'translateY';\n        }\n    }\n\n    protected debounce(func: () => any, wait: number): () => any {\n        const throttled = this.throttleTrailing(func, wait);\n        const result = function () {\n            (throttled as any).cancel();\n            throttled.apply(this, arguments);\n        };\n        result.cancel = () => {\n            (throttled as any).cancel();\n        };\n\n        return result;\n    }\n\n    protected throttleTrailing(func: () => any, wait: number): () => any {\n        let timeout;\n        let _arguments = arguments;\n        const result = function () {\n            const _this = this;\n            _arguments = arguments\n\n            if (timeout) {\n                return;\n            }\n\n            if (wait <= 0) {\n                func.apply(_this, _arguments);\n            } else {\n                timeout = setTimeout(() => {\n                    timeout = undefined;\n                    func.apply(_this, _arguments);\n                }, wait);\n            }\n        };\n        result.cancel = () => {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = undefined;\n            }\n        };\n\n        return result;\n    }\n\n    protected refresh_internal(itemsArrayModified: boolean, refreshCompletedCallback?: () => void, maxRunTimes: number = 2): void {\n        // note: maxRunTimes is to force it to keep recalculating if the previous iteration caused a re-render\n        //       (different sliced items in viewport or scrollPosition changed).\n        // The default of 2x max will probably be accurate enough without causing too large a performance bottleneck\n        // The code would typically quit out on the 2nd iteration anyways. The main time it'd think more than 2 runs\n        // would be necessary would be for vastly different sized child items or if this is the 1st time the items array\n        // was initialized.\n        // Without maxRunTimes, If the user is actively scrolling this code would become an infinite loop until they\n        // stopped scrolling. This would be okay, except each scroll event would start an additional infinite loop. We\n        // want to short-circuit it to prevent this.\n\n        if (itemsArrayModified && this.previousViewPort && this.previousViewPort.scrollStartPosition > 0) {\n            // if items were prepended, scroll forward to keep same items visible\n            const oldViewPort = this.previousViewPort;\n            const oldViewPortItems = this.viewPortItems;\n\n\t\t\tconst oldRefreshCompletedCallback = refreshCompletedCallback;\n\t\t\trefreshCompletedCallback = () => {\n\t\t\t\tconst scrollLengthDelta = this.previousViewPort.scrollLength - oldViewPort.scrollLength;\n\t\t\t\tif (scrollLengthDelta > 0 && this.viewPortItems) {\n                    const offset = this.previousViewPort.startIndex - this.previousViewPort.startIndexWithBuffer;\n                    const oldStartItem = oldViewPortItems[offset];\n                    const oldStartItemIndex = this.items.findIndex(x => this.compareItems(oldStartItem, x));\n\n                    if (oldStartItemIndex > this.previousViewPort.startIndex) {\n                        let itemOrderChanged = false;\n                        for (let i = 1, l = this.viewPortItems.length - offset; i < l; ++i) {\n                            if (!this.compareItems(this.items[oldStartItemIndex + i], oldViewPortItems[offset + i])) {\n                                itemOrderChanged = true;\n                                break;\n                            }\n                        }\n\n                        if (!itemOrderChanged) {\n                            this.scrollToPosition(this.previousViewPort.scrollStartPosition + scrollLengthDelta,\n                                0, oldRefreshCompletedCallback);\n                            return;\n                        }\n                    }\n                }\n\n                if (oldRefreshCompletedCallback) {\n                    oldRefreshCompletedCallback();\n                }\n            };\n        }\n\n        this.zone.runOutsideAngular(() => {\n            requestAnimationFrame(() => {\n\n                if (itemsArrayModified) {\n                    this.resetWrapGroupDimensions();\n                }\n                const viewport = this.calculateViewport();\n\n                const startChanged = itemsArrayModified || viewport.startIndex !== this.previousViewPort.startIndex;\n                const endChanged = itemsArrayModified || viewport.endIndex !== this.previousViewPort.endIndex;\n                const scrollLengthChanged = viewport.scrollLength !== this.previousViewPort.scrollLength;\n                const paddingChanged = viewport.padding !== this.previousViewPort.padding;\n                const scrollPositionChanged = viewport.scrollStartPosition !== this.previousViewPort.scrollStartPosition ||\n                    viewport.scrollEndPosition !== this.previousViewPort.scrollEndPosition ||\n                    viewport.maxScrollPosition !== this.previousViewPort.maxScrollPosition;\n\n                this.previousViewPort = viewport;\n\n                if (scrollLengthChanged) {\n                    this.renderer.setStyle(this.invisiblePaddingElementRef.nativeElement, 'transform', `${this._invisiblePaddingProperty}(${viewport.scrollLength})`);\n                    this.renderer.setStyle(this.invisiblePaddingElementRef.nativeElement, 'webkitTransform', `${this._invisiblePaddingProperty}(${viewport.scrollLength})`);\n                }\n\n                if (paddingChanged) {\n                    if (this.useMarginInsteadOfTranslate) {\n                        this.renderer.setStyle(this.contentElementRef.nativeElement, this._marginDir, `${viewport.padding}px`);\n                    } else {\n                        this.renderer.setStyle(this.contentElementRef.nativeElement, 'transform', `${this._translateDir}(${viewport.padding}px)`);\n                        this.renderer.setStyle(this.contentElementRef.nativeElement, 'webkitTransform', `${this._translateDir}(${viewport.padding}px)`);\n                    }\n                }\n\n                if (this.headerElementRef) {\n                    const scrollPosition = this.getScrollElement()[this._scrollType];\n                    const containerOffset = this.getElementsOffset();\n                    const offset = Math.max(scrollPosition - viewport.padding - containerOffset +\n                        this.headerElementRef.nativeElement.clientHeight, 0);\n                    this.renderer.setStyle(this.headerElementRef.nativeElement, 'transform', `${this._translateDir}(${offset}px)`);\n                    this.renderer.setStyle(this.headerElementRef.nativeElement, 'webkitTransform', `${this._translateDir}(${offset}px)`);\n                }\n\n                const changeEventArg: IPageInfo = (startChanged || endChanged) ? {\n                    startIndex: viewport.startIndex,\n                    endIndex: viewport.endIndex,\n                    scrollStartPosition: viewport.scrollStartPosition,\n                    scrollEndPosition: viewport.scrollEndPosition,\n                    startIndexWithBuffer: viewport.startIndexWithBuffer,\n                    endIndexWithBuffer: viewport.endIndexWithBuffer,\n                    maxScrollPosition: viewport.maxScrollPosition\n                } : undefined;\n\n\n                if (startChanged || endChanged || scrollPositionChanged) {\n                    const handleChanged = () => {\n                        // update the scroll list to trigger re-render of components in viewport\n                        this.viewPortItems = viewport.startIndexWithBuffer >= 0 && viewport.endIndexWithBuffer >= 0 ?\n                            this.items.slice(viewport.startIndexWithBuffer, viewport.endIndexWithBuffer + 1) : [];\n                        this.vsUpdate.emit(this.viewPortItems);\n\n                        if (startChanged) {\n                            this.vsStart.emit(changeEventArg);\n                        }\n\n                        if (endChanged) {\n                            this.vsEnd.emit(changeEventArg);\n                        }\n\n                        if (startChanged || endChanged) {\n                            this.changeDetectorRef.markForCheck();\n                            this.vsChange.emit(changeEventArg);\n                        }\n\n                        if (maxRunTimes > 0) {\n                            this.refresh_internal(false, refreshCompletedCallback, maxRunTimes - 1);\n                            return;\n                        }\n\n                        if (refreshCompletedCallback) {\n                            refreshCompletedCallback();\n                        }\n                    };\n\n\n                    if (this.executeRefreshOutsideAngularZone) {\n                        handleChanged();\n                    } else {\n                        this.zone.run(handleChanged);\n                    }\n                } else {\n                    if (maxRunTimes > 0 && (scrollLengthChanged || paddingChanged)) {\n                        this.refresh_internal(false, refreshCompletedCallback, maxRunTimes - 1);\n                        return;\n                    }\n\n                    if (refreshCompletedCallback) {\n                        refreshCompletedCallback();\n                    }\n                }\n            });\n        });\n    }\n\n    protected getScrollElement(): HTMLElement {\n        return this.parentScroll instanceof Window ? document.scrollingElement || document.documentElement ||\n            document.body : this.parentScroll || this.element.nativeElement;\n    }\n\n    protected addScrollEventHandlers(): void {\n        if (this.isAngularUniversalSSR) {\n            return;\n        }\n\n        const scrollElement = this.getScrollElement();\n\n        this.removeScrollEventHandlers();\n\n        this.zone.runOutsideAngular(() => {\n            if (this.parentScroll instanceof Window) {\n                this.disposeScrollHandler = this.renderer.listen('window', 'scroll', this.onScroll);\n                this.disposeResizeHandler = this.renderer.listen('window', 'resize', this.onScroll);\n            } else {\n                this.disposeScrollHandler = this.renderer.listen(scrollElement, 'scroll', this.onScroll);\n                if (this._checkResizeInterval > 0) {\n                    this.checkScrollElementResizedTimer = (setInterval(() => {\n                        this.checkScrollElementResized();\n                    }, this._checkResizeInterval) as any);\n                }\n            }\n        });\n    }\n\n    protected removeScrollEventHandlers(): void {\n        if (this.checkScrollElementResizedTimer) {\n            clearInterval(this.checkScrollElementResizedTimer);\n        }\n\n        if (this.disposeScrollHandler) {\n            this.disposeScrollHandler();\n            this.disposeScrollHandler = undefined;\n        }\n\n        if (this.disposeResizeHandler) {\n            this.disposeResizeHandler();\n            this.disposeResizeHandler = undefined;\n        }\n    }\n\n    protected getElementsOffset(): number {\n        if (this.isAngularUniversalSSR) {\n            return 0;\n        }\n\n        let offset = 0;\n\n        if (this.containerElementRef && this.containerElementRef.nativeElement) {\n            offset += this.containerElementRef.nativeElement[this._offsetType];\n        }\n\n        if (this.parentScroll) {\n            const scrollElement = this.getScrollElement();\n            const elementClientRect = this.getElementSize(this.element.nativeElement);\n            const scrollClientRect = this.getElementSize(scrollElement);\n            if (this.horizontal) {\n                offset += elementClientRect.left - scrollClientRect.left;\n            } else {\n                offset += elementClientRect.top - scrollClientRect.top;\n            }\n\n            if (!(this.parentScroll instanceof Window)) {\n                offset += scrollElement[this._scrollType];\n            }\n        }\n\n        return offset;\n    }\n\n    protected countItemsPerWrapGroup(): number {\n        if (this.isAngularUniversalSSR) {\n            return Math.round(this.horizontal ? this.ssrViewportHeight / this.ssrChildHeight : this.ssrViewportWidth / this.ssrChildWidth);\n        }\n\n        const propertyName = this.horizontal ? 'offsetLeft' : 'offsetTop';\n        const children = ((this.containerElementRef && this.containerElementRef.nativeElement) ||\n            this.contentElementRef.nativeElement).children;\n\n        const childrenLength = children ? children.length : 0;\n        if (childrenLength === 0) {\n            return 1;\n        }\n\n        const firstOffset = children[0][propertyName];\n        let result = 1;\n        while (result < childrenLength && firstOffset === children[result][propertyName]) {\n            ++result;\n        }\n\n        return result;\n    }\n\n    protected getScrollStartPosition(): number {\n        let windowScrollValue;\n        if (this.parentScroll instanceof Window) {\n            windowScrollValue = window[this._pageOffsetType];\n        }\n\n        return windowScrollValue || this.getScrollElement()[this._scrollType] || 0;\n    }\n\n    protected resetWrapGroupDimensions(): void {\n        const oldWrapGroupDimensions = this.wrapGroupDimensions;\n        this.invalidateAllCachedMeasurements();\n\n        if (!this.enableUnequalChildrenSizes || !oldWrapGroupDimensions || oldWrapGroupDimensions.numberOfKnownWrapGroupChildSizes === 0) {\n            return;\n        }\n\n        const itemsPerWrapGroup: number = this.countItemsPerWrapGroup();\n        for (let wrapGroupIndex = 0; wrapGroupIndex < oldWrapGroupDimensions.maxChildSizePerWrapGroup.length; ++wrapGroupIndex) {\n            const oldWrapGroupDimension: WrapGroupDimension = oldWrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex];\n            if (!oldWrapGroupDimension || !oldWrapGroupDimension.items || !oldWrapGroupDimension.items.length) {\n                continue;\n            }\n\n            if (oldWrapGroupDimension.items.length !== itemsPerWrapGroup) {\n                return;\n            }\n\n            let itemsChanged = false;\n            const arrayStartIndex = itemsPerWrapGroup * wrapGroupIndex;\n            for (let i = 0; i < itemsPerWrapGroup; ++i) {\n                if (!this.compareItems(oldWrapGroupDimension.items[i], this.items[arrayStartIndex + i])) {\n                    itemsChanged = true;\n                    break;\n                }\n            }\n\n            if (!itemsChanged) {\n                ++this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\n                this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths += oldWrapGroupDimension.childWidth || 0;\n                this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights += oldWrapGroupDimension.childHeight || 0;\n                this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex] = oldWrapGroupDimension;\n            }\n        }\n    }\n\n    protected calculateDimensions(): IDimensions {\n        const scrollElement = this.getScrollElement();\n\n        const maxCalculatedScrollBarSize = 25; // Note: Formula to auto-calculate doesn't work for ParentScroll,\n                                               //       so we default to this if not set by consuming application\n        this.calculatedScrollbarHeight = Math.max(Math.min(scrollElement.offsetHeight - scrollElement.clientHeight,\n            maxCalculatedScrollBarSize), this.calculatedScrollbarHeight);\n        this.calculatedScrollbarWidth = Math.max(Math.min(scrollElement.offsetWidth - scrollElement.clientWidth,\n            maxCalculatedScrollBarSize), this.calculatedScrollbarWidth);\n\n        let viewportWidth = scrollElement.offsetWidth - (this.scrollbarWidth || this.calculatedScrollbarWidth ||\n            (this.horizontal ? 0 : maxCalculatedScrollBarSize));\n        let viewportHeight = scrollElement.offsetHeight - (this.scrollbarHeight || this.calculatedScrollbarHeight ||\n            (this.horizontal ? maxCalculatedScrollBarSize : 0));\n\n        const content = (this.containerElementRef && this.containerElementRef.nativeElement) || this.contentElementRef.nativeElement;\n\n        const itemsPerWrapGroup = this.countItemsPerWrapGroup();\n        let wrapGroupsPerPage;\n\n        let defaultChildWidth;\n        let defaultChildHeight;\n\n        if (this.isAngularUniversalSSR) {\n            viewportWidth = this.ssrViewportWidth;\n            viewportHeight = this.ssrViewportHeight;\n            defaultChildWidth = this.ssrChildWidth;\n            defaultChildHeight = this.ssrChildHeight;\n            const itemsPerRow = Math.max(Math.ceil(viewportWidth / defaultChildWidth), 1);\n            const itemsPerCol = Math.max(Math.ceil(viewportHeight / defaultChildHeight), 1);\n            wrapGroupsPerPage = this.horizontal ? itemsPerRow : itemsPerCol;\n        } else if (!this.enableUnequalChildrenSizes) {\n            if (content.children.length > 0) {\n                if (!this.childWidth || !this.childHeight) {\n                    if (!this.minMeasuredChildWidth && viewportWidth > 0) {\n                        this.minMeasuredChildWidth = viewportWidth;\n                    }\n                    if (!this.minMeasuredChildHeight && viewportHeight > 0) {\n                        this.minMeasuredChildHeight = viewportHeight;\n                    }\n                }\n\n                const child = content.children[0];\n                const clientRect = this.getElementSize(child);\n                this.minMeasuredChildWidth = Math.min(this.minMeasuredChildWidth, clientRect.width);\n                this.minMeasuredChildHeight = Math.min(this.minMeasuredChildHeight, clientRect.height);\n            }\n\n            defaultChildWidth = this.childWidth || this.minMeasuredChildWidth || viewportWidth;\n            defaultChildHeight = this.childHeight || this.minMeasuredChildHeight || viewportHeight;\n            const itemsPerRow = Math.max(Math.ceil(viewportWidth / defaultChildWidth), 1);\n            const itemsPerCol = Math.max(Math.ceil(viewportHeight / defaultChildHeight), 1);\n            wrapGroupsPerPage = this.horizontal ? itemsPerRow : itemsPerCol;\n        } else {\n            let scrollOffset = scrollElement[this._scrollType] - (this.previousViewPort ? this.previousViewPort.padding : 0);\n\n            let arrayStartIndex = this.previousViewPort.startIndexWithBuffer || 0;\n            let wrapGroupIndex = Math.ceil(arrayStartIndex / itemsPerWrapGroup);\n\n            let maxWidthForWrapGroup = 0;\n            let maxHeightForWrapGroup = 0;\n            let sumOfVisibleMaxWidths = 0;\n            let sumOfVisibleMaxHeights = 0;\n            wrapGroupsPerPage = 0;\n\n            // tslint:disable-next-line:prefer-for-of\n            for (let i = 0; i < content.children.length; ++i) {\n                ++arrayStartIndex;\n                const child = content.children[i];\n                const clientRect = this.getElementSize(child);\n\n                maxWidthForWrapGroup = Math.max(maxWidthForWrapGroup, clientRect.width);\n                maxHeightForWrapGroup = Math.max(maxHeightForWrapGroup, clientRect.height);\n\n                if (arrayStartIndex % itemsPerWrapGroup === 0) {\n                    const oldValue = this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex];\n                    if (oldValue) {\n                        --this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\n                        this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths -= oldValue.childWidth || 0;\n                        this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights -= oldValue.childHeight || 0;\n                    }\n\n                    ++this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\n                    const items = this.items.slice(arrayStartIndex - itemsPerWrapGroup, arrayStartIndex);\n                    this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex] = {\n                        childWidth: maxWidthForWrapGroup,\n                        childHeight: maxHeightForWrapGroup,\n                        items\n                    };\n                    this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths += maxWidthForWrapGroup;\n                    this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights += maxHeightForWrapGroup;\n\n                    if (this.horizontal) {\n                        let maxVisibleWidthForWrapGroup = Math.min(maxWidthForWrapGroup,\n                            Math.max(viewportWidth - sumOfVisibleMaxWidths, 0));\n                        if (scrollOffset > 0) {\n                            const scrollOffsetToRemove = Math.min(scrollOffset, maxVisibleWidthForWrapGroup);\n                            maxVisibleWidthForWrapGroup -= scrollOffsetToRemove;\n                            scrollOffset -= scrollOffsetToRemove;\n                        }\n\n                        sumOfVisibleMaxWidths += maxVisibleWidthForWrapGroup;\n                        if (maxVisibleWidthForWrapGroup > 0 && viewportWidth >= sumOfVisibleMaxWidths) {\n                            ++wrapGroupsPerPage;\n                        }\n                    } else {\n                        let maxVisibleHeightForWrapGroup = Math.min(maxHeightForWrapGroup,\n                            Math.max(viewportHeight - sumOfVisibleMaxHeights, 0));\n                        if (scrollOffset > 0) {\n                            const scrollOffsetToRemove = Math.min(scrollOffset, maxVisibleHeightForWrapGroup);\n                            maxVisibleHeightForWrapGroup -= scrollOffsetToRemove;\n                            scrollOffset -= scrollOffsetToRemove;\n                        }\n\n                        sumOfVisibleMaxHeights += maxVisibleHeightForWrapGroup;\n                        if (maxVisibleHeightForWrapGroup > 0 && viewportHeight >= sumOfVisibleMaxHeights) {\n                            ++wrapGroupsPerPage;\n                        }\n                    }\n\n                    ++wrapGroupIndex;\n\n                    maxWidthForWrapGroup = 0;\n                    maxHeightForWrapGroup = 0;\n                }\n            }\n\n            const averageChildWidth = this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths /\n                this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\n            const averageChildHeight = this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights /\n                this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\n            defaultChildWidth = this.childWidth || averageChildWidth || viewportWidth;\n            defaultChildHeight = this.childHeight || averageChildHeight || viewportHeight;\n\n            if (this.horizontal) {\n                if (viewportWidth > sumOfVisibleMaxWidths) {\n                    wrapGroupsPerPage += Math.ceil((viewportWidth - sumOfVisibleMaxWidths) / defaultChildWidth);\n                }\n            } else {\n                if (viewportHeight > sumOfVisibleMaxHeights) {\n                    wrapGroupsPerPage += Math.ceil((viewportHeight - sumOfVisibleMaxHeights) / defaultChildHeight);\n                }\n            }\n        }\n\n        const itemCount = this.items.length;\n        const itemsPerPage = itemsPerWrapGroup * wrapGroupsPerPage;\n        const pageCountFractional = itemCount / itemsPerPage;\n        const numberOfWrapGroups = Math.ceil(itemCount / itemsPerWrapGroup);\n\n        let scrollLength = 0;\n\n        const defaultScrollLengthPerWrapGroup = this.horizontal ? defaultChildWidth : defaultChildHeight;\n        if (this.enableUnequalChildrenSizes) {\n            let numUnknownChildSizes = 0;\n            for (let i = 0; i < numberOfWrapGroups; ++i) {\n                const childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] &&\n                    this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];\n                if (childSize) {\n                    scrollLength += childSize;\n                } else {\n                    ++numUnknownChildSizes;\n                }\n            }\n\n            scrollLength += Math.round(numUnknownChildSizes * defaultScrollLengthPerWrapGroup);\n        } else {\n            scrollLength = numberOfWrapGroups * defaultScrollLengthPerWrapGroup;\n        }\n\n        if (this.headerElementRef) {\n            scrollLength += this.headerElementRef.nativeElement.clientHeight;\n        }\n\n        const viewportLength = this.horizontal ? viewportWidth : viewportHeight;\n        const maxScrollPosition = Math.max(scrollLength - viewportLength, 0);\n\n        return {\n            childHeight: defaultChildHeight,\n            childWidth: defaultChildWidth,\n            itemCount,\n            itemsPerPage,\n            itemsPerWrapGroup,\n            maxScrollPosition,\n            pageCount_fractional: pageCountFractional,\n            scrollLength,\n            viewportLength,\n            wrapGroupsPerPage,\n        };\n    }\n\n    protected calculatePadding(arrayStartIndexWithBuffer: number, dimensions: IDimensions): number {\n        if (dimensions.itemCount === 0) {\n            return 0;\n        }\n\n        const defaultScrollLengthPerWrapGroup = dimensions[this._childScrollDim];\n        const startingWrapGroupIndex = Math.floor(arrayStartIndexWithBuffer / dimensions.itemsPerWrapGroup) || 0;\n\n        if (!this.enableUnequalChildrenSizes) {\n            return defaultScrollLengthPerWrapGroup * startingWrapGroupIndex;\n        }\n\n        let numUnknownChildSizes = 0;\n        let result = 0;\n        for (let i = 0; i < startingWrapGroupIndex; ++i) {\n            const childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] &&\n                this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];\n            if (childSize) {\n                result += childSize;\n            } else {\n                ++numUnknownChildSizes;\n            }\n        }\n        result += Math.round(numUnknownChildSizes * defaultScrollLengthPerWrapGroup);\n\n        return result;\n    }\n\n    protected calculatePageInfo(scrollPosition: number, dimensions: IDimensions): IPageInfo {\n        let scrollPercentage = 0;\n        if (this.enableUnequalChildrenSizes) {\n            const numberOfWrapGroups = Math.ceil(dimensions.itemCount / dimensions.itemsPerWrapGroup);\n            let totalScrolledLength = 0;\n            const defaultScrollLengthPerWrapGroup = dimensions[this._childScrollDim];\n            for (let i = 0; i < numberOfWrapGroups; ++i) {\n                const childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] &&\n                    this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];\n                if (childSize) {\n                    totalScrolledLength += childSize;\n                } else {\n                    totalScrolledLength += defaultScrollLengthPerWrapGroup;\n                }\n\n                if (scrollPosition < totalScrolledLength) {\n                    scrollPercentage = i / numberOfWrapGroups;\n                    break;\n                }\n            }\n        } else {\n            scrollPercentage = scrollPosition / dimensions.scrollLength;\n        }\n\n        const startingArrayIndexFractional = Math.min(Math.max(scrollPercentage * dimensions.pageCount_fractional, 0),\n            dimensions.pageCount_fractional) * dimensions.itemsPerPage;\n\n        const maxStart = dimensions.itemCount - dimensions.itemsPerPage - 1;\n        let arrayStartIndex = Math.min(Math.floor(startingArrayIndexFractional), maxStart);\n        arrayStartIndex -= arrayStartIndex % dimensions.itemsPerWrapGroup; // round down to start of wrapGroup\n\n        if (this.stripedTable) {\n            const bufferBoundary = 2 * dimensions.itemsPerWrapGroup;\n            if (arrayStartIndex % bufferBoundary !== 0) {\n                arrayStartIndex = Math.max(arrayStartIndex - arrayStartIndex % bufferBoundary, 0);\n            }\n        }\n\n        let arrayEndIndex = Math.ceil(startingArrayIndexFractional) + dimensions.itemsPerPage - 1;\n        const endIndexWithinWrapGroup = (arrayEndIndex + 1) % dimensions.itemsPerWrapGroup;\n        if (endIndexWithinWrapGroup > 0) {\n            arrayEndIndex += dimensions.itemsPerWrapGroup - endIndexWithinWrapGroup; // round up to end of wrapGroup\n        }\n\n        if (isNaN(arrayStartIndex)) {\n            arrayStartIndex = 0;\n        }\n        if (isNaN(arrayEndIndex)) {\n            arrayEndIndex = 0;\n        }\n\n        arrayStartIndex = Math.min(Math.max(arrayStartIndex, 0), dimensions.itemCount - 1);\n        arrayEndIndex = Math.min(Math.max(arrayEndIndex, 0), dimensions.itemCount - 1);\n\n        const bufferSize = this.bufferAmount * dimensions.itemsPerWrapGroup;\n        const startIndexWithBuffer = Math.min(Math.max(arrayStartIndex - bufferSize, 0), dimensions.itemCount - 1);\n        const endIndexWithBuffer = Math.min(Math.max(arrayEndIndex + bufferSize, 0), dimensions.itemCount - 1);\n\n        return {\n            startIndex: arrayStartIndex,\n            endIndex: arrayEndIndex,\n            startIndexWithBuffer,\n            endIndexWithBuffer,\n            scrollStartPosition: scrollPosition,\n            scrollEndPosition: scrollPosition + dimensions.viewportLength,\n            maxScrollPosition: dimensions.maxScrollPosition\n        };\n    }\n\n    protected calculateViewport(): IViewport {\n        const dimensions = this.calculateDimensions();\n        const offset = this.getElementsOffset();\n\n        let scrollStartPosition = this.getScrollStartPosition();\n        if (scrollStartPosition > (dimensions.scrollLength + offset) && !(this.parentScroll instanceof Window)) {\n            scrollStartPosition = dimensions.scrollLength;\n        } else {\n            scrollStartPosition -= offset;\n        }\n        scrollStartPosition = Math.max(0, scrollStartPosition);\n\n        const pageInfo = this.calculatePageInfo(scrollStartPosition, dimensions);\n        const newPadding = this.calculatePadding(pageInfo.startIndexWithBuffer, dimensions);\n        const newScrollLength = dimensions.scrollLength;\n\n        return {\n            startIndex: pageInfo.startIndex,\n            endIndex: pageInfo.endIndex,\n            startIndexWithBuffer: pageInfo.startIndexWithBuffer,\n            endIndexWithBuffer: pageInfo.endIndexWithBuffer,\n            padding: Math.round(newPadding),\n            scrollLength: Math.round(newScrollLength),\n            scrollStartPosition: pageInfo.scrollStartPosition,\n            scrollEndPosition: pageInfo.scrollEndPosition,\n            maxScrollPosition: pageInfo.maxScrollPosition\n        };\n    }\n}\n\n@NgModule({\n    exports: [VirtualScrollerComponent],\n    declarations: [VirtualScrollerComponent],\n    imports: [CommonModule],\n    providers: [\n        {\n            provide: 'virtual-scroller-default-options',\n            useFactory: VIRTUAL_SCROLLER_DEFAULT_OPTIONS_FACTORY\n        }\n    ]\n})\nexport class VirtualScrollerModule {\n}\n"]}